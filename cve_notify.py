#!/usr/bin/env python
#
# CVE notifier - Sends an email alert when new exploits are posted for a given product
# For full details, see the included README
#

import requests
import sendgrid
import sys
import os.path
import json
import jinja2

class Data():
    """
    Maintains a JSON list of CVEs which we've heard about in the past
    """

    def __init__(self,datafile='data'):
        """
        Sets up the datafile, and loads in the known CVE from disk.
        """

        # If the file does not yet exist, return an empty list
        if not os.path.isfile(datafile):
            self.products = {}
        else:
            # Otherwise, read the file, and return the JSON obj
            try:
                with open(datafile, 'r') as f:
                    self.products = json.load(f)
            except:
                print("Error, cannot retrieve JSON")
                sys.exit(2)

    def save(self,datafile='data'):
        """
        Writes the datafile containing status on CVEs
        """
        try:
            with open(datafile, 'w') as f:
                json.dump(obj=self.products,fp=f)
        except e:
            print("Unable to save JSON")
            sys.exit(2)

    def cve_already_stored(self,cve):
        """
        Checks all products, to see if we have this CVE already
        """
        for product in self.products:
            for old_cve in self.products[product]:
                if old_cve['cve_id'] == cve:
                    return True

    def add(self,product,details):
        """
        Add a CVE to our data object.
        Does NOT save to disk until save() is run.
        """

        if product not in self.products:
            self.products[product] = []

        # Add the CVE if we don't already have it.
        if not self.cve_already_stored(details['cve_id']):
            self.products[product].append(details)

class Alert():
    """
    Maintains internal list of new CVEs, and sends one alert.
    """

    def __init__(self):
        """
        Setup the alert
        """

        # Read in the email config information
        with open('credentials', 'r') as f:
            self.credentials = json.load(f)


        # Sendgrid setup
        self.client = sendgrid.SendGridClient(self.credentials['key'])
        self.message = sendgrid.Mail()
        self.message.add_to(self.credentials['to'])
        self.message.set_from(self.credentials['from'])
        # List of vulnerabilities, indexed by product.
        self.products = {}


    def add(self,cve,product,summary,url):
        """
        Stores details of the cve for the alert
        """

        details = {}
        details['cve'] = cve
        details['product'] = product
        details['summary'] = summary
        details['url'] = url

        # Create this product in the alert list
        if product not in self.products:
            self.products[product] = []

        # Store this alert.
        self.products[product].append(details)


    def send(self):
        """
        Connects to the SMTP relay, and sends the alert
        """
        cvecount = 0

        # Abort out if there are no new CVEs to send.
        for product in self.products:
            for cve in self.products[product]:
                cvecount += 1
        if cvecount < 1:
            return

        # Generate a list of products
        products = ""
        for product in self.products:
            products = products + product + " "
        self.message.set_subject("New Exploits detected for " + products)

        # Generate the message body

        env = jinja2.Environment(loader=jinja2.FileSystemLoader('./templates'))
        template = env.get_template('alert_email.html')
        html =  template.render(products=self.products)

        self.message.set_html(html)
        self.client.send(self.message)

def retrieve_cve_list(url):
    """
    Retrieves a list of CVEs from a given url
    """
    try:
        r = requests.get(url)
        if r.status_code != 200:
            print("Cannot retrieve list")
            sys.exit(2)
        return r.json()
    except e:
        print("Cannot retrieve list")
        sys.exit(2)

if __name__ == "__main__":
    # This block will be run by default when this tool is invoked from the command line.

    # Create a list of products to monitor.
    products = []
    # Add/Watch OpenSSL and OpenSSH
    products.append(("OpenSSL","http://www.cvedetails.com/json-feed.php?numrows=30&vendor_id=217&product_id=0&version_id=0&hasexp=0&opec=0&opov=0&opcsrf=0&opfileinc=0&opgpriv=0&opsqli=0&opxss=0&opdirt=0&opmemc=0&ophttprs=0&opbyp=0&opginf=0&opdos=0&orderby=3&cvssscoremin=0"))
    products.append(("OpenSSH","http://www.cvedetails.com/json-feed.php?numrows=30&vendor_id=97&product_id=585&version_id=0&hasexp=0&opec=0&opov=0&opcsrf=0&opfileinc=0&opgpriv=0&opsqli=0&opxss=0&opdirt=0&opmemc=0&ophttprs=0&opbyp=0&opginf=0&opdos=0&orderby=3&cvssscoremin=0"))

    # Load in data from previous runs of this command, to ensure we don't alert on the same CVE twice.
    data = Data()

    # Create our Alert instance, so we only send one email
    alert = Alert()

    # Check all defined products.
    for product in products:
        json_list = retrieve_cve_list(product[1])
        # Iterate through the list of vulnerabilites for this product.
        for vuln in json_list:
            # Store this CVE, iff we've never seen it before.
            if not data.cve_already_stored(vuln['cve_id']):
                # Store the vulnerability in memory
                data.add(product[0],vuln)
                # Alert on the vulnerability
                alert.add(cve=vuln['cve_id'],product=product[0],summary=vuln['summary'],url=vuln['url'])

    # Send our notification
    alert.send()

    # Save out our updated datafile
    # We want to do this AFTER we send the notification, so any exceptions kill us before we get here.
    data.save()
